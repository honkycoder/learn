
1.继承的实现(属性拷贝)
    将父对象中所有的内容赋值一份给子对象

    方式一: 遍历父对象,取出所有的内容赋值给子对象
    方式二: Object.assign
        参数1: 需要拷贝的对象
        后面的参数: 依次被拷贝的对象

    存在的问题: 如果父对象中的某个属性的值是引用类型,那么赋值过来的是内存地址,子对象的这个属性和父对象的这个属性共享同一份数据,互相有影响

2.继承的实现(原型式继承)
    如何实现: 子构造函数的原型对象等于父构造函数的原型对象
        步骤:
            1.提供一个子构造函数和一个父构造函数
            2.设置子构造函数的原型对象等于父构造函数的原型对象
            3.修正构造器属性

        存在的问题:
            1.使用子构造函数创建的对象,无法获取父构造函数内的属性和方法
            2.使用子构造函数创建的对象,访问对象的constructor的值是父构造函数
            3.子构造函数原型对象和父构造函数的原型对象一致,共享同一份数据,互相有影响

3.扩展内置对象
    给内置构造函数的原型对象添加属性和方法
        存在问题:
            如果每个人都这样去扩展内置对象,会造成日后难以维护,还会造成覆盖的问题

4.安全的扩展内置对象
    步骤:
        1.提供一个构造函数
        2.设置这个构造函数的原型对象是内置构造函数的实例化对象
        3.修正构造器属性
        4.给这个构造函数的原型对象添加属性和方法

5.原型链的结构
    1.每一个对象都是由构造函数创建出来的
    2.每一个构造函数都由一个与之相关联的原型对象
    3.原型对象也是对象,意味着这个对象也是由构造函数创建出来的
    4.原型对象的构造函数也有原型对象,这个原型对象也是一个对象
    5.原型对象的构造函数的原型对象也是由构造函数创建出来的,这个构造函数也有原型对象

    以上形成的一种链式的结构就称为原型链
    原型链的顶端是Object.prototype
    Object.prototype.__proto__ == null

6.原型链中属性的访问原则
    1.当使用对象.属性访问这个属性的值的时候,首先在对象本身查找有没有这个属性,如果有直接返回对应的值
    2.如果没有,就到这个对象的原型对象上去查找有没有这个属性,如果有就直接返回对应的值
    3.如果没有,就到这个对象的原型对象的原型对象上去查找有没有这个属性,如果有就直接返回对应的值
    4.如果没有,就重复上面步骤,直到Object.prototype去查找有没有这个属性,如果有就直接返回对应的值
    5.如果没有就返回undefined或者报错

7.原型链继承: 子构造函数的原型对象等于父构造函数的实例化对象
    步骤:
        1.提供一个子构造函数和一个父构造函数
        2.设置子构造函数的原型对象是父构造函数的实例化对象
        3.修正构造器属性

8.复杂的原型链的示例
    动物 -> 人 -> 学生 -> 男同学

9.原型链的注意点:
        1.在实现原型链继承之后,再设置构造器属性
        2.在实现原型链继承之后,再设置原型对象的属性和方法
        3.设置原型的属性和方法,只能通过对象的动态特性来设置,不能通过字面量的方式设置
--上午--
1.面向对象的三大特性
封装: 利用对象封装变量和函数
继承:
    现实生活中的继承: 一个人获取另外一个人的资源或财富的一种方法
    程序中的继承: 一个类(对象)获取另外一个类(对象)的属性和方法
    面向对象的特点: 有没有类(C++ JAVA)
    JS中没有类,但是它的支持面向对象的语言(基于对象的语言)
多态: 同一个操作作用于不同的对象有不同效果

2.字面量的方式创建对象
var obj = {}
存在的问题: 创建多个同类型的对象,无法复用,重复代码过度,冗余度高

3.内置构造函数创建对象
Object Array Function... String Number Boolean
    var obj = new Object();
    存在的问题: 创建多个同类型的对象,无法复用,重复代码过度,冗余度高

4.简单的工厂函数的方式创建对象
    存在的问题: 创建不同类型的对象,无法分辨

5.自定义构造函数
    1.步骤:
        1.提供一个构造函数
        2.通过this设置属性和方法
        3.使用new 构造函数创建对象

    2.自定义构造函数说明
        1.构造函数首字母大写(程序员之间的约定)
        2.使用new 构造函数创建对象

    3.自定义构造函数的内部实现
        1.使用new 构造函数, 内部默认会创建一个新的对象
        2.将这个对象赋值给this
        3.默认返回这个对象

    4.自定义构造函数与工厂函数创建对象的区别?
        1.构造函数首字母大写(程序员之间的约定)
        2.构造函数内部会默认创建对象,并将这个对象赋值给this,最终返回这个对象
        3.构造函数使用new 构造函数创建对象
        4.工厂函数需要手动创建对象,手动返回对象

    5.自定义构造函数的返回值
        1.如果构造函数内部没有显示的返回值,那么返回内部创建好的对象
        2.如果构造函数内部有显示的返回值, 看情况
            1.返回值类型为值类型: 直接忽略
            2.返回值类型为引用类型: 会覆盖创建好的对象,返回该引用类型

6.构造函数注意事项01
    函数传值:
        函数可以作为函数的参数
        函数作为对象的方法来调用,this -> 对象

    对象类型:
        instanceof
        语法: 对象 instanceof 构造函数
        返回值: 布尔类型

    构造器属性: 每一个对象都能够访问constructor属性,这个属性是构造函数原型对象的属性,默认的值就是这个构造函数(默认情况下,构造函数创建出来的对象,可以访问这个构造函数原型对象上的属性和方法)

7.构造函数注意事项02
    直接调用构造函数和使用new调用构造函数的区别
    new: 创建对象,返回对象
    构造函数: 内部会做一些初始化操作
        1.new 构造函数, 内部会创建一个新的对象,并将这个对象赋值给this,最终返回这个对象
        2.直接调用构造函数,内部是this指向window,在初始化的时候,会给window添加属性和方法,会造成全局变量污染

8.构造函数方式创建对象存在的问题
    使用构造函数创建多个对象,对于方法的函数会创建多次,会造成资源浪费的问题

    解决资源浪费问题: 保证无论创建多少次对象,方法的函数只会创建一次(函数写在外面)
    会造成的问题:
        1.写在外面就成为了全局函数,会造成全局变量污染
        2.破坏了封装性
        3.结构性不好

--下午--
1.构造函数的原型对象
    1.什么是原型对象?
    当一个构造函数被创建出来的时候,系统默认会创建一个对象与之相关联,这个对象就是这个构造函数的原型对象

2.原型对象的作用?
    构造函数创建出来的对象,默认情况下可以使用构造函数原型对象上的属性和方法

3.如何访问原型对象?
    1.构造函数.prototype
    2.对象.__proto__

4.如何设置原型对象?
    1.原型对象也是对象,可以利用对象的动态特性添加属性和方法
    2.使用字面量的方式(替换原型对象)

5.约定: 对象构造函数的原型对象
    构造函数的原型对象
    构造函数的原型
    对象的原型对象
    对象的原型

2.使用原型对象解决构造函数方式创建对象的问题
    问题: 使用构造函数多次创建对象,对于方法的函数会创建多次,从而引起资源浪费,可以通过将这个函数放在外面来解决问题,但是放在外面就成为了全局函数,会造成全局变量污染
    如何解决?
    将对象的方法写在构造函数的原型对象上

3.实例化和实例
    实例化: 构造函数创建对象的过程
    实例: 构造函数创建出来的对象

4.原型的使用方法
    1.原型对象也是对象,可以利用对象的动态特性添加属性和方法
    2.使用字面量的方式(替换原型)

5.替换原型的注意点
    1.替换前后创建出来的对象的原型对象不是同一个
        解决方案: 建议替换后再创建对象
    2.替换之前原型对象的constructor的值是Person,替换之后原型对象的constructor的值是Object
        如何解决: 给替换后的原型对象添加constructor属性值为Person

    6.构造器属性相关(constructor): 每个对象都能访问constructor属性,这个属性是构造函数原型对象的属性,默认指向该构造函数

7.使用原型对象的注意事项
    1.如何访问原型对象的属性
        1.构造函数.prototype.属性
        2.对象.属性

    2.属性的访问(读取)原则
        当要获取某个属性值的时候,先在自身上查找有没有这个属性(实例属性),如果有就直接返回对应的值,如果没有就去对象的原型对象上查找有没有这个属性(原型属性),如果有就返回对应的值,如果找不到,返回undefined或者报错

3.修改原型对象属性的值
    1.给对象的属性赋值,如果这个对象有这个属性则是修改,如果没有这个属性,则是添加
    2.修改原型对象属性的方式2种
        1.构造函数.prototype.属性进行修改
        2.如果原型对象的属性是引用类型
            1.对象.属性.属性进行修改
            2.构造函数.prototype.属性.属性进行修改

8.__proto__
    每个对象都由__proto__这个属性,这个属性的值默认是构造函数的原型对象

    注意点: 这个属性不是ECMAScript规定的,是非标准的,由各大浏览器厂商添加的,为了方便程序员调试,正规的项目不要使用 (ie不支持)

9.hasOwnProperty: 判断这个属性是否是某个对象的实例属性
    in: 判断这个属性是否是某个对象的属性(实例属性 + 原型属性)
        需求: 判断这个属性是原型对象的属性,并且仅仅是原型对象的属性
        return 属性名 in 对象 && !对象.hasOwnProperty(属性名)


10.isPrototypeOf: 判断这个对象是否是指定对象的原型对象
    obj.isPrototypeOf(o)
--上午--

1.继承的实现(属性拷贝)
    将父对象中所有的内容赋值一份给子对象

    方式一: 遍历父对象,取出所有的内容赋值给子对象
    方式二: Object.assign
        参数1: 需要拷贝的对象
        后面的参数: 依次被拷贝的对象

    存在的问题: 如果父对象中的某个属性的值是引用类型,那么赋值过来的是内存地址,子对象的这个属性和父对象的这个属性共享同一份数据,互相有影响

2.继承的实现(原型式继承)
    如何实现: 子构造函数的原型对象等于父构造函数的原型对象
    步骤:
        1.提供一个子构造函数和一个父构造函数
        2.设置子构造函数的原型对象等于父构造函数的原型对象
        3.修正构造器属性

    存在的问题:
        1.使用子构造函数创建的对象,无法获取父构造函数内的属性和方法
        2.使用子构造函数创建的对象,访问对象的constructor的值是父构造函数
        3.子构造函数原型对象和父构造函数的原型对象一致,共享同一份数据,互相有影响

3.扩展内置对象
    给内置构造函数的原型对象添加属性和方法
    存在问题:
        如果每个人都这样去扩展内置对象,会造成日后难以维护,还会造成覆盖的问题

4.安全的扩展内置对象
    步骤:
    1.提供一个构造函数
    2.设置这个构造函数的原型对象是内置构造函数的实例化对象
    3.修正构造器属性
    4.给这个构造函数的原型对象添加属性和方法

5.原型链的结构
    1.每一个对象都是由构造函数创建出来的
    2.每一个构造函数都由一个与之相关联的原型对象
    3.原型对象也是对象,意味着这个对象也是由构造函数创建出来的
    4.原型对象的构造函数也有原型对象,这个原型对象也是一个对象
    5.原型对象的构造函数的原型对象也是由构造函数创建出来的,这个构造函数也有原型对象

    以上形成的一种链式的结构就称为原型链
    原型链的顶端是Object.prototype
    Object.prototype.__proto__ == null

6.原型链中属性的访问原则
    1.当使用对象.属性访问这个属性的值的时候,首先在对象本身查找有没有这个属性,如果有直接返回对应的值
    2.如果没有,就到这个对象的原型对象上去查找有没有这个属性,如果有就直接返回对应的值
    3.如果没有,就到这个对象的原型对象的原型对象上去查找有没有这个属性,如果有就直接返回对应的值
    4.如果没有,就重复上面步骤,直到Object.prototype去查找有没有这个属性,如果有就直接返回对应的值
    5.如果没有就返回undefined或者报错

7.原型链继承: 子构造函数的原型对象等于父构造函数的实例化对象
    步骤:
        1.提供一个子构造函数和一个父构造函数
        2.设置子构造函数的原型对象是父构造函数的实例化对象
        3.修正构造器属性

8.复杂的原型链的示例
    动物 -> 人 -> 学生 -> 男同学

9.原型链的注意点:
    1.在实现原型链继承之后,再设置构造器属性
    2.在实现原型链继承之后,再设置原型对象的属性和方法
    3.设置原型的属性和方法,只能通过对象的动态特性来设置,不能通过字面量的方式设置

--下午--

1.原型链继承的问题?
    原型链继承: 子构造函数的原型对象等于父构造函数的实例化对象
        存在的问题:
            1.使用子构造函数创建对象的时候,无法给父构造函数传参
            2.子构造函数的原型对象等于父构造函数的实例化对象,那么子构造函数创建出来的对象的原型成员就是父构造函数的实例化对象的实例成员,如果这个实例成员里面有引用类型,那么通过子构造函数创建出来的对象都共享这块数据,修改一个会影响其他的对象

2.Object.create: 创建对象并指定原型对象
    var o = Object.create(obj);
    obj是o的原型对象

3.call 和 apply
    1.在ES3给函数的原型对象添加了2个方法
        Function.prototype.call
        Function.prototype.apply

    2.作用: 借用其他对象的方法

    3.参数:
        参数1: 要借用方法的对象(函数内部this的绑定值)
        后面的参数:
            call: 参数列表,依次为函数的实参
            apply: 数组,数组中的元素依次为函数的实参

    this在函数中的指向
    1.函数作为对象的方法: this -> 这个对象
    2.函数作为普通方式调用: this -> window
    3.函数作为构造函数去调用: this -> 内部创建的对象
    4.(apply | call): this -> 第一参数

4.借用构造函数继承的基本写法
    1.解决了原型链继承不能传参的问题
    2.不能访问父构造函数原型对象的属性和方法

5.组合继承的基本写法
    1.借用构造函数来获取父构造函数的实例成员
    2.使用原型式继承来获取父构造函数的原型成员
    存在的问题: 子构造函数的原型对象和父构造函数的原型对象一致,共享同一份数据,互相有影响

6.深拷贝和浅拷贝
    浅拷贝(地址拷贝): 将父对象中所有的内容赋值给子对象,如果是引用类型,赋值过来的是内存地址,子对象的这个属性和父对象的这个属性共享同一份数据,互相有影响

    深拷贝(内容拷贝): 只拷贝内容,不拷贝地址
        1.提供一个函数,有2个参数,第一个参数是需要拷贝的对象,第二个参数是被拷贝的对象
        2.校验处理,如果2个参数中有一个不是对象就直接返回false
        3.遍历被拷贝对象的所有属性
        4.判断这个属性是否是被拷贝对象的实例属性,这里只拷贝实例属性,不拷贝原型属性
        5.判断这个属性的值的类型
            1.如果是值类型,给要拷贝的对象新增这个属性并将这个属性的值赋值给这个对象
            2.如果是引用类型,判断这个引用类型的值是否是一个数组
                1.如果是一个数组,就给要拷贝的对象动态添加这个属性,并赋值为一个空数组
                2.如果不是一个数组,就给要拷贝的对象动态添加这个属性,并赋值为一个空对象
                3.再次调用这个方法将空对象或者空数组作为第一个参数,把这个属性的值作为第二个参数,再进行拷贝

7.Array.isArray: 判断这个对象是否是一个数组
兼容性问题: ie8不支持

    toString(): 获取对象的字符串描述信息(字符串)

    Object.prototype.toString.call(对象);

8.面试题: 如果一个对象作为属性,那么会默认调用这个对象的toString方法

9.通过深拷贝实现继承(完美继承)
    1.获取实例成员: 借用构造函数继承
    2.获取原型成员: 深拷贝父构造函数的原型对象

10.基本包装类型
    1.直接调用函数和直接赋值效果一致
    2.new Number(10) 等价于 new Object(10)

11.基本包装类型的注意点
等于(==): 判断两边的值是否相等
            引用类型和引用类型进行判断,判断的是内存地址
            引用类型和值类型进行判断,对引用类型进行隐式转换取出对应的值再进行判断
            值类型和值类型进行判断,判断具体的值
全等于(===): 除了判断值也会判断类型

    为什么基本数据类型可以调用属性和方法?
    内部实现:
        1.当使用基本数据类型调用属性和方法的时候,内部会创建一个与之相对应的对象
        2.使用这个对象去调用属性和方法
        3.获取结果后返回,最后销毁这个对象

12.Number的使用注意点
    1.可以用变量调用方法
    2.可以用表达式调用方法
    3.不可以直接使用值调用方法

--上午--
1.闭包:
闭: 关闭,封闭的意思,对外部不开放
包: 包裹

闭包技术:
    1.内部作用域可以访问外部作用域,反过来不行
    2.有时候想要让外部作用访问内部作用域中的数据
    3.闭包技术就是可以间接的访问内部作用域中私有数据的方法

获取内部作用域中的数据的方式:
    1.直接return对应的数据
    2.闭包: 对return的数据进行包装(函数)

    通过外部作用域访问内部作用域中的私有数据,这个数据最终是被函数包装的,这个就是闭包技术

2.闭包获取和设置数据
<script>
    function fn() {
        var name = 'zs';
        var age = 20;
        return {
            getName: function () {
                return name;
            },
            getAge: function () {
                return age;
            },
            setName: function (newName) {
                if (newName != undefined) {
                    name = newName;
                }
            },
            setAge: function (newAge) {
                if (newAge != undefined) {
                    age = newAge;
                }
            }
        }
    }
</script>

3.闭包的作用
    1.外部作用域可以访问内部作用域中私有的数据
    2.访问和设置数据必须使用固定的接口
    3.在设置值的时候,可以做校验处理
    4.延长了变量的声明周期

4.定时器和闭包的执行
    定时器:
    setTimeout: 只会执行一次(延迟执行函数)
    setInterval: 每隔一段时间执行一次

    参数:
        参数1: 回调函数
        参数2: 间隔时间(ms),1s == 1000ms

JS任务组成:
    1.渲染任务: 写的代码在浏览器中看到的效果
    2.JS主要任务: for循环
    3.JS事件型任务: 点击任务,定时器任务

JS执行任务的特点:
    JS是单线程
    进程: 一个正在运行的应用程序,没有运行的不是

    线程: 在进程中执行任务(一个进程想要执行任务,必须要有一个线程)

    串行执行: 在线程中执行任务是串行的,多个任务会按照顺序 一个一个的执行,同一时间只能执行一个任务

    多线程: 在进程中开启多条线程,每条线程可以执行不同的任务

    多线程原理: CPU同一时间只能处理一条线程,同一时间只有一条线程在工作
        多线程并发(同时)执行: CPU快速的在多条线程之间来回调度,如果速度足够快,就能达到多线程并发执行的假象
        1s --> 1万 0.0001s

5.div事件和闭包
<script>
    //    for (var i = 0; i < divs.length; i++) {
    //        (function (j) {
    //            divs[j].onclick = function () {
    //                console.log(j);
    //            }
    //        })(i)
    //
    //    }
</script>

6.函数的特殊性
    1.函数也是对象，对象能做的函数也能做
    2.对象可以动态添加属性和方法，函数也可以
    3.对象可以作为函数的参数和返回值，函数也可以
    4.函数可以创建作用域
    5.函数还可以调用

7.函数的定义说明和name属性
    函数的定义：
    1.函数声明
    2.函数表达式
    3.Function构造函数

    函数的name值： 函数名
        如果function后面写了这个名字，则以这个名字为准，如果没有写则以变量名位置
        函数的name默认情况下不能修改

8.函数的回调：
函数可以作为函数的参数
    对象的方法作为函数的参数，再次调用就是普通调用，内部的this会指向window，需要绑定this值

--下午--

1.函数作为返回值
<script>
    function sum() {
        var a = 0;
        return function () {
            return ++a;
        }
    }
</script>

2.惰性函数
    函数中的内容需要调用一次才可以确定

    惰性函数的注意点:
        1.在调用函数前设置的属性和方法,调用之后会丢失
        2.将函数赋值给一个变量,永远都不会更新
        3.将函数赋值给一个对象的属性,永远都不会更新

3.即时调用函数: 立即调用
    组成: 函数 + 2个小括号
    函数: (参数和返回值)
        第一个小括号将函数包裹起来
        第二个小括号执行第一个小括号中的函数
<script>
    (function () {
        console.log('第一种写法');
    })();

    (function () {
        console.log('第二种写法');
    }());
</script>

4.即时 对象 初始化
好处: 不会创建全局变量,减少了全局变量污染的问题
<script>
    ({
        name: 'zs',
        age: 20,
        getName: function () {
            return name;
        },
        getAge: function () {
            return age;
        },
        init: function () {
            console.log(this.getName());
            console.log(this.getAge());
        }
    }).init();
</script>

5.设计模式的简单说明
    设计模式(套路)
    为了解决在开发中遇到的问题而提出的方法

    在公司中一个完整的项目需要有一套设计模式(架构师)
    一个优秀的设计模式必须具备2个条件: 高内聚,低耦合

6.工厂函数创建对象
步骤:
    1.提供一个工厂函数
    2.创建一个对象
    3.设置对象属性和方法
    4.返回创建好的对象

7.工厂模式的实现:
    工厂模式: 大批量的生产同一类型的产品
    需求: 生产手机

步骤:
    1.提供一个父构造函数
    2.设置父构造函数的原型对象的方法(用于父构造函数创建出来的对象或者子构造函数创建出来的对象可以共享这个方法)
    3.给父构造函数提供多个静态方法,用于定制合作伙伴(有哪些型号的手机可以生产)
    4.给父构造函数提供一个静态工厂方法,用于生产不同型号的产品,接收一个型号名
        4.1.接收型号名
        4.2.通过型号名,判断父构造函数是否有这个方法,如果没有则抛出异常
        4.3.通过型号名在父构造函数中获取方法(子构造函数),设置这个方法原型对象为父构造函数的实例化对象,实现原型链继承
        4.4.使用子构造函数实例化对象
        4.5.返回这个创建好对象
    5.使用静态工厂方法生产不同型号的手机
